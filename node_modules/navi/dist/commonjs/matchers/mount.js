"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Chunks_1 = require("../Chunks");
var Mapping_1 = require("../Mapping");
var Matcher_1 = require("../Matcher");
var concat_1 = __importDefault(require("../utils/concat"));
function mount(paths) {
    if (!paths) {
        throw new Error("mount() must be supplied with a paths object.");
    }
    var patterns = Object.keys(paths);
    var nonWildcardPatterns = patterns.filter(function (pattern) { return pattern !== '*'; });
    if (process.env.NODE_ENV !== 'production') {
        var invalidPaths = patterns.filter(function (pattern) { return typeof paths[pattern] !== 'function'; });
        if (invalidPaths.length > 0) {
            throw new TypeError("The given paths: " + invalidPaths.join(', ') + " are invalid. " +
                "Their values should be matcher objects. See https://frontarm.com/navi/en/reference/matchers/");
        }
    }
    // Wildcards in PatternMap objects are null (\0) characters, so they'll
    // always be sorted to the top. As such, by sorting the patterns, the
    // most specific (i.e. without wildcard) will always be at the bottom.
    var mappings = nonWildcardPatterns
        .map(function (pattern) { return Mapping_1.createMapping(pattern, paths[pattern]); })
        .sort(function (x, y) { return compareStrings(x.key, y.key); });
    return function (child) {
        return function mountMatcherGenerator(request) {
            var chunks, childIterators, childResults, childChunkLists, crawlRequests, crawler, crawling, crawlTuplesPromise, crawlTuples_1, error_1, i, mapping, childRequest, wildcardMatcher, i, childResult, foundChunks, i, childChunks;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        childResults = [];
                        childChunkLists = [];
                        crawlRequests = [];
                        crawler = request.crawler;
                        crawling = crawler && (request.path === '' || request.path === '/');
                        if (!crawling) return [3 /*break*/, 5];
                        crawlTuplesPromise = createCrawlTuplesPromise(paths, crawler, request);
                        crawlTuplesPromise.then(function (x) { crawlTuples_1 = x; }, function (y) { return error_1 = y; });
                        _a.label = 1;
                    case 1: return [4 /*yield*/, [Chunks_1.createChunk('busy', request, { promise: crawlTuplesPromise })]];
                    case 2:
                        _a.sent();
                        if (error_1) {
                            throw error_1;
                        }
                        _a.label = 3;
                    case 3:
                        if (!crawlTuples_1) return [3 /*break*/, 1];
                        _a.label = 4;
                    case 4:
                        childIterators = crawlTuples_1.map(function (_a, i) {
                            var _b = __read(_a, 2), matcher = _b[0], crawlItem = _b[1];
                            var crawlRequest = __assign(__assign({}, request), { mountpath: crawlItem.url.pathname, url: '', path: '' });
                            crawlRequests[i] = crawlRequest;
                            return Matcher_1.createMatcherIterator(matcher(child), crawlRequest, crawlRequest.mountpath);
                        });
                        return [3 /*break*/, 6];
                    case 5:
                        // Start from the beginning and take the first result, as child mounts
                        // are sorted such that the first matching mount is the the most
                        // precise match (and we always want to use the most precise match).
                        for (i = mappings.length - 1; i >= 0; i--) {
                            mapping = mappings[i];
                            childRequest = Mapping_1.matchAgainstPathname(request, mapping);
                            if (childRequest) {
                                childIterators = [Matcher_1.createMatcherIterator(mapping.matcher(child), childRequest, mapping.pattern)];
                                // The first match is always the only match, as we don't allow
                                // for ambiguous patterns.
                                break;
                            }
                        }
                        // If no matches are found, default to the wildcard pattern (if it
                        // exists)
                        if (!childIterators) {
                            wildcardMatcher = paths['*'];
                            if (wildcardMatcher) {
                                childIterators = [Matcher_1.createMatcherIterator(wildcardMatcher(child), request, '*')];
                            }
                        }
                        _a.label = 6;
                    case 6:
                        if (childIterators) {
                            for (i = 0; i < childIterators.length; i++) {
                                childResult = childResults[i];
                                if (!childResult || !childResult.done) {
                                    childResult = childResults[i] = childIterators[i].next();
                                }
                                if (childResult && !childResult.done) {
                                    childChunkLists[i] = childResult.value;
                                }
                            }
                        }
                        chunks = [Chunks_1.createChunk('mount', request, { patterns: patterns })];
                        foundChunks = false;
                        for (i = 0; i < childResults.length; i++) {
                            childChunks = childChunkLists[i];
                            if (childChunks) {
                                foundChunks = true;
                                if (crawling && !childChunks.some(isMountChunk)) {
                                    chunks = chunks.concat(Chunks_1.createChunk('crawl', crawlRequests[i]));
                                }
                                chunks = chunks.concat(childChunks);
                            }
                        }
                        if (!crawler && !foundChunks) {
                            chunks.push(Chunks_1.createNotFoundChunk(request));
                        }
                        return [4 /*yield*/, chunks];
                    case 7:
                        _a.sent();
                        _a.label = 8;
                    case 8:
                        if (chunks.filter(isBusy).length) return [3 /*break*/, 6];
                        _a.label = 9;
                    case 9: return [2 /*return*/];
                }
            });
        };
    };
}
exports.mount = mount;
function compareStrings(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
function isBusy(chunk) {
    return chunk.type === 'busy';
}
function createCrawlTuplesPromise(paths, crawler, parentRequest) {
    return __awaiter(this, void 0, void 0, function () {
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = concat_1.default;
                    return [4 /*yield*/, Promise.all(Object.entries(paths).map(function (_a) {
                            var _b = __read(_a, 2), pattern = _b[0], matcher = _b[1];
                            return crawler(pattern === '*' ? '' : pattern, parentRequest).then(createTuplesWith(matcher));
                        }))];
                case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
            }
        });
    });
}
function createTuplesWith(x) {
    return function (ys) { return ys.map(function (y) { return [x, y]; }); };
}
function isMountChunk(chunk) {
    return chunk.type === 'mount';
}
//# sourceMappingURL=mount.js.map