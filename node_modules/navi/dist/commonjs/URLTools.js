"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var parsePattern = /((((\/?(?:[^\/\?#]+\/+)*)([^\?#]*)))?(\?[^#]+)?)(#.*)?/;
function createURLDescriptor(urlOrDescriptor, _a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.removeHash, removeHash = _c === void 0 ? false : _c, _d = _b.trailingSlash, trailingSlash = _d === void 0 ? null : _d;
    var hostname;
    var pathname;
    var query;
    var search;
    var hash;
    if (typeof urlOrDescriptor === 'string') {
        var matches = parsePattern.exec(urlOrDescriptor);
        if (!matches) {
            throw new Error("Couldn't parse the provided URL.");
        }
        hostname = '';
        pathname = modifyTrailingSlash(matches[2] || '', trailingSlash);
        search = matches[6] || '';
        query = parseQuery(search);
        hash = matches[7] || '';
    }
    else {
        hostname = urlOrDescriptor.hostname || '';
        pathname = modifyTrailingSlash(urlOrDescriptor.pathname || '', trailingSlash);
        query = urlOrDescriptor.query || (urlOrDescriptor.search ? parseQuery(urlOrDescriptor.search) : {});
        search = urlOrDescriptor.search || stringifyQuery(query);
        hash = urlOrDescriptor.hash || '';
    }
    return {
        hostname: hostname,
        pathname: pathname,
        query: query,
        search: search,
        hash: removeHash ? '' : hash,
        href: pathname + search + hash,
    };
}
exports.createURLDescriptor = createURLDescriptor;
function parseQuery(queryString, leadingCharacter) {
    if (leadingCharacter === void 0) { leadingCharacter = '?'; }
    if (!queryString || queryString[0] != leadingCharacter) {
        return {};
    }
    var query = {};
    var queryParts = queryString.slice(1).split('&');
    for (var i = 0, len = queryParts.length; i < len; i++) {
        var x = queryParts[i].split('=');
        query[x[0]] = x[1] ? decodeURIComponent(x[1]) : '';
    }
    return query;
}
exports.parseQuery = parseQuery;
function stringifyQuery(query, leadingCharacter) {
    if (leadingCharacter === void 0) { leadingCharacter = '?'; }
    var keys = Object.keys(query);
    if (keys.length === 0) {
        return '';
    }
    var parts = [];
    for (var i = 0, len = keys.length; i < len; i++) {
        var key = keys[i];
        var value = String(query[key]);
        parts.push(value === '' ? key : key + '=' + encodeURIComponent(value));
    }
    return leadingCharacter + parts.join('&');
}
exports.stringifyQuery = stringifyQuery;
function splitPath(path) {
    if (path === '') {
        return [];
    }
    return path.split('/');
}
// users/789/, profile      => users/789/profile/
// /users/123, .           => /users/123
// /users/123, ..          => /users
// /users/123, ../..       => /
// /a/b/c/d,   ../../one   => /a/b/one
// /a/b/c/d,   .././one/    => /a/b/c/one/
function joinPaths(base) {
    var paths = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        paths[_i - 1] = arguments[_i];
    }
    var allSegments = splitPath(base);
    for (var i = 0; i < paths.length; i++) {
        allSegments.push.apply(allSegments, __spread(splitPath(paths[i])));
    }
    var pathSegments = [];
    var lastSegmentIndex = allSegments.length - 1;
    for (var i = 0; i <= lastSegmentIndex; i++) {
        var segment = allSegments[i];
        if (segment === "..") {
            pathSegments.pop();
        }
        // Allow empty segments on the first and final characters, so that leading
        // and trailing slashes will not be affected.
        else if (segment !== '.' && (segment !== '' || i === 0 || i === lastSegmentIndex)) {
            pathSegments.push(segment);
        }
    }
    return pathSegments.join('/');
}
exports.joinPaths = joinPaths;
function modifyTrailingSlash(pathname, action) {
    var hasTrailingSlash = pathname.slice(-1) === '/';
    if (action === 'add' && !hasTrailingSlash) {
        return pathname + '/';
    }
    else if (action === 'remove' && hasTrailingSlash && pathname.length > 1) {
        return pathname.slice(0, -1);
    }
    return pathname;
}
exports.modifyTrailingSlash = modifyTrailingSlash;
//# sourceMappingURL=URLTools.js.map