"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Router_1 = require("./Router");
var Route_1 = require("./Route");
var resolve_1 = require("./resolve");
var URLTools_1 = require("./URLTools");
var Observable_1 = require("./Observable");
var Errors_1 = require("./Errors");
var Deferred_1 = require("./Deferred");
// Keep track of the number of navigations since the last steady route,
// so we can detect and bail out of navigation loops.
var MAX_NAVIGATIONS_SINCE_STEADY = 100;
var Navigation = /** @class */ (function () {
    function Navigation(options) {
        var _this = this;
        this.handleUnsubscribe = function (observer) {
            var index = _this.observers.indexOf(observer);
            if (index !== -1) {
                _this.observers.splice(index, 1);
            }
        };
        // Allows for either the location or route or both to be changed at once.
        this.handleChunkList = function (chunks) {
            var isSteady = true;
            var location = _this._history.location;
            for (var i = 0; i < chunks.length; i++) {
                var chunk = chunks[i];
                if (chunk.type === 'busy') {
                    isSteady = false;
                }
                if (chunk.type === 'state') {
                    _this.ignoreNextLocationChange = true;
                    _this._history.replace(__assign(__assign({}, location), { state: setLocationRequestState(location.state, chunk.state) }));
                }
                if (chunk.type === 'redirect') {
                    var revertedState = revertLocationState(location.state);
                    if (revertedState) {
                        _this.ignoreNextLocationChange = true;
                        _this._history.replace(__assign(__assign({}, location), { state: revertedState }));
                        _this._history.push(chunk.to);
                    }
                    else {
                        _this._history.replace(chunk.to);
                    }
                    return;
                }
            }
            _this.setRoute([{ type: 'url', url: URLTools_1.createURLDescriptor(_this.lastHandledLocation) }]
                .concat(chunks)
                .reduce(Route_1.routeReducer, undefined), isSteady);
        };
        this._history = options.history;
        this.observers = [];
        this.isLastRouteSteady = false;
        this.navigationsSinceSteady = 0;
        this.basename = options.basename;
        this.matcher = options.routes;
        this._router = new Router_1.Router({
            context: options.context,
            routes: options.routes,
            basename: options.basename,
        });
        this.trailingSlash =
            options.trailingSlash === undefined ? 'remove' : options.trailingSlash;
        this.unlisten = this._history.listen(function (location) {
            return _this.handleLocationChange(location, false);
        });
        this.navigate = this.navigate.bind(this);
    }
    Navigation.prototype.dispose = function () {
        this.observers.length = 0;
        this.unlisten();
        delete this.unlisten;
        delete this._history;
        if (this.observableSubscription) {
            this.observableSubscription.unsubscribe();
        }
        delete this.observableSubscription;
        delete this._router;
        delete this.waitUntilSteadyDeferred;
        delete this.lastRoute;
        delete this._router;
    };
    Navigation.prototype.go = function (n) {
        return __awaiter(this, void 0, void 0, function () {
            var urlChanged;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        urlChanged = new Promise(function (resolve) {
                            var unlisten = _this._history.listen(function () {
                                unlisten();
                                resolve();
                            });
                        });
                        this._history.go(n);
                        return [4 /*yield*/, urlChanged];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.getRoute()];
                }
            });
        });
    };
    Navigation.prototype.goBack = function () {
        return this.go(-1);
    };
    Navigation.prototype.goForward = function () {
        return this.go(1);
    };
    Navigation.prototype.navigate = function (url, options) {
        if (options === void 0) { options = {}; }
        var nextURL;
        if (typeof url === 'string') {
            nextURL = URLTools_1.createURLDescriptor(url);
        }
        else if (url.url) {
            options = url;
            nextURL = URLTools_1.createURLDescriptor(options.url);
        }
        else if (url) {
            nextURL = URLTools_1.createURLDescriptor(url);
        }
        else {
            throw new Error("You must specify a URL or state to navigation.navigate().");
        }
        var currentLocation = this._history.location;
        // Default to replace when we're not changing the URL itself, but only
        // changing state.
        var shouldReplace = options.replace ||
            (options.replace !== false &&
                currentLocation.pathname === nextURL.pathname &&
                currentLocation.search === nextURL.search &&
                currentLocation.hash === nextURL.hash);
        this._history[shouldReplace ? 'replace' : 'push']({
            pathname: nextURL.pathname,
            search: nextURL.search,
            hash: nextURL.hash,
            state: packLocationState({
                revertTo: shouldReplace ? currentLocation.state : undefined,
                method: options.method,
                headers: options.headers,
                body: options.body,
                state: options.state,
            }),
        });
        return this.getRoute();
    };
    // TODO:
    // Put any history state on a "prefetched state" object, so that on
    // navigation, any prefetched state can be reused.
    Navigation.prototype.prefetch = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, resolve_1.resolve({
                            basename: this.basename,
                            routes: this.matcher,
                            context: this._router.context,
                            url: url,
                        })];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    Navigation.prototype.refresh = function () {
        this.handleLocationChange(this._history.location, true);
        return this.getRoute();
    };
    Navigation.prototype.setContext = function (context) {
        this._router.setContext(context);
        return this.refresh();
    };
    /**
     * Get the latest Route object, regardless of whether it is loading.
     *
     * This is named as `getCurrentValue()` so that Navigation objects can be
     * used with React's `createSubscription()`, and other tools that follow
     * the same specification.
     */
    Navigation.prototype.getCurrentValue = function () {
        return this.lastRoute;
    };
    /**
     * If loading, returns a promise to the non-busy route. Otherwise, returns
     * the current route.
     */
    Navigation.prototype.getRoute = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.isLastRouteSteady) {
                    return [2 /*return*/, this.lastRoute];
                }
                else if (!this.waitUntilSteadyDeferred) {
                    this.waitUntilSteadyDeferred = new Deferred_1.Deferred();
                }
                return [2 /*return*/, this.waitUntilSteadyDeferred.promise];
            });
        });
    };
    /**
     * Returns the current history state
     */
    Navigation.prototype.extractState = function () {
        return this._history.location.state;
    };
    /**
     * If you're using code splitting, you'll need to subscribe to changes to
     * Route, as the route may change as new code chunks are received.
     */
    Navigation.prototype.subscribe = function (onNextOrObserver, onError, onComplete) {
        var observer = Observable_1.createOrPassthroughObserver(onNextOrObserver, onError, onComplete);
        this.observers.push(observer);
        return new Observable_1.SimpleSubscription(this.handleUnsubscribe, observer);
    };
    Navigation.prototype.handleLocationChange = function (location, force) {
        if (this.ignoreNextLocationChange) {
            this.ignoreNextLocationChange = false;
            return;
        }
        if (++this.navigationsSinceSteady > MAX_NAVIGATIONS_SINCE_STEADY) {
            console.error("Detected possible navigation loop with " + MAX_NAVIGATIONS_SINCE_STEADY + " navigations between steady routes. Bailing.");
            return;
        }
        // Ensure the pathname always has a trailing `/`, so that we don't
        // have multiple URLs referring to the same page.
        if (this.trailingSlash !== null) {
            var modifiedPathname = URLTools_1.modifyTrailingSlash(location.pathname, this.trailingSlash);
            if (location.pathname !== modifiedPathname) {
                this._history.replace(__assign(__assign({}, location), { pathname: modifiedPathname }));
                return;
            }
        }
        var url = URLTools_1.createURLDescriptor(location);
        var lastHandledLocation = this.lastHandledLocation;
        this.lastHandledLocation = location;
        if (this.observableSubscription) {
            this.observableSubscription.unsubscribe();
        }
        var observable = this._router.createObservable(url, unpackLocationState(location.state));
        if (observable) {
            this.observableSubscription = observable.subscribe(this.handleChunkList);
        }
        else if (!lastHandledLocation) {
            throw new Errors_1.OutOfRootError(url);
        }
    };
    Navigation.prototype.setRoute = function (route, isSteady) {
        if (route !== this.lastRoute) {
            this.lastRoute = route;
            this.isLastRouteSteady = isSteady;
            if (isSteady) {
                this.navigationsSinceSteady = 0;
            }
            for (var i = 0; i < this.observers.length; i++) {
                this.observers[i].next(route);
            }
            // Check this.isLastRouteSteady instead of isSteady, in case one of our
            // subscribers causes navigation again.
            if (this.isLastRouteSteady && this.waitUntilSteadyDeferred) {
                this.waitUntilSteadyDeferred.resolve(route);
                delete this.waitUntilSteadyDeferred;
            }
        }
    };
    return Navigation;
}());
exports.Navigation = Navigation;
var NAVI_STATE_KEY = '__navi__';
/**
 * Set the value of request.state without changing the other request data.
 */
function setLocationRequestState(locationState, newState) {
    var _a;
    if (locationState === void 0) { locationState = {}; }
    return __assign(__assign({}, newState), (_a = {}, _a[NAVI_STATE_KEY] = locationState[NAVI_STATE_KEY], _a));
}
function packLocationState(_a) {
    var _b;
    var revertTo = _a.revertTo, state = _a.state, requestDataWithoutState = __rest(_a, ["revertTo", "state"]);
    if (revertTo) {
        revertTo = __assign({}, revertTo);
        if (revertTo[NAVI_STATE_KEY]) {
            delete revertTo[NAVI_STATE_KEY].revertTo;
        }
    }
    return __assign(__assign({}, state), (_b = {}, _b[NAVI_STATE_KEY] = {
        requestDataWithoutState: requestDataWithoutState,
        revertTo: revertTo,
    }, _b));
}
function unpackLocationState(state) {
    if (state === void 0) { state = {}; }
    var requestDataState = __assign({}, state);
    delete requestDataState[NAVI_STATE_KEY];
    var naviState = state[NAVI_STATE_KEY] || {};
    return __assign(__assign({}, naviState.requestDataWithoutState), { state: Object.keys(requestDataState).length ? requestDataState : undefined });
}
function revertLocationState(state) {
    if (state === void 0) { state = {}; }
    var naviState = state[NAVI_STATE_KEY] || {};
    return naviState.revertTo;
}
//# sourceMappingURL=Navigation.js.map