(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('history')) :
    typeof define === 'function' && define.amd ? define(['exports', 'history'], factory) :
    (global = global || self, factory(global.Navi = {}, global.History));
}(this, function (exports, history) { 'use strict';

    var __read = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread = (undefined && undefined.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
        return ar;
    };
    var parsePattern = /((((\/?(?:[^\/\?#]+\/+)*)([^\?#]*)))?(\?[^#]+)?)(#.*)?/;
    function createURLDescriptor(urlOrDescriptor, _a) {
        var _b = _a === void 0 ? {} : _a, _c = _b.removeHash, removeHash = _c === void 0 ? false : _c, _d = _b.trailingSlash, trailingSlash = _d === void 0 ? null : _d;
        var hostname;
        var pathname;
        var query;
        var search;
        var hash;
        if (typeof urlOrDescriptor === 'string') {
            var matches = parsePattern.exec(urlOrDescriptor);
            if (!matches) {
                throw new Error("Couldn't parse the provided URL.");
            }
            hostname = '';
            pathname = modifyTrailingSlash(matches[2] || '', trailingSlash);
            search = matches[6] || '';
            query = parseQuery(search);
            hash = matches[7] || '';
        }
        else {
            hostname = urlOrDescriptor.hostname || '';
            pathname = modifyTrailingSlash(urlOrDescriptor.pathname || '', trailingSlash);
            query = urlOrDescriptor.query || (urlOrDescriptor.search ? parseQuery(urlOrDescriptor.search) : {});
            search = urlOrDescriptor.search || stringifyQuery(query);
            hash = urlOrDescriptor.hash || '';
        }
        return {
            hostname: hostname,
            pathname: pathname,
            query: query,
            search: search,
            hash: removeHash ? '' : hash,
            href: pathname + search + hash,
        };
    }
    function parseQuery(queryString, leadingCharacter) {
        if (leadingCharacter === void 0) { leadingCharacter = '?'; }
        if (!queryString || queryString[0] != leadingCharacter) {
            return {};
        }
        var query = {};
        var queryParts = queryString.slice(1).split('&');
        for (var i = 0, len = queryParts.length; i < len; i++) {
            var x = queryParts[i].split('=');
            query[x[0]] = x[1] ? decodeURIComponent(x[1]) : '';
        }
        return query;
    }
    function stringifyQuery(query, leadingCharacter) {
        if (leadingCharacter === void 0) { leadingCharacter = '?'; }
        var keys = Object.keys(query);
        if (keys.length === 0) {
            return '';
        }
        var parts = [];
        for (var i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            var value = String(query[key]);
            parts.push(value === '' ? key : key + '=' + encodeURIComponent(value));
        }
        return leadingCharacter + parts.join('&');
    }
    function splitPath(path) {
        if (path === '') {
            return [];
        }
        return path.split('/');
    }
    // users/789/, profile      => users/789/profile/
    // /users/123, .           => /users/123
    // /users/123, ..          => /users
    // /users/123, ../..       => /
    // /a/b/c/d,   ../../one   => /a/b/one
    // /a/b/c/d,   .././one/    => /a/b/c/one/
    function joinPaths(base) {
        var paths = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            paths[_i - 1] = arguments[_i];
        }
        var allSegments = splitPath(base);
        for (var i = 0; i < paths.length; i++) {
            allSegments.push.apply(allSegments, __spread(splitPath(paths[i])));
        }
        var pathSegments = [];
        var lastSegmentIndex = allSegments.length - 1;
        for (var i = 0; i <= lastSegmentIndex; i++) {
            var segment = allSegments[i];
            if (segment === "..") {
                pathSegments.pop();
            }
            // Allow empty segments on the first and final characters, so that leading
            // and trailing slashes will not be affected.
            else if (segment !== '.' && (segment !== '' || i === 0 || i === lastSegmentIndex)) {
                pathSegments.push(segment);
            }
        }
        return pathSegments.join('/');
    }
    function modifyTrailingSlash(pathname, action) {
        var hasTrailingSlash = pathname.slice(-1) === '/';
        if (action === 'add' && !hasTrailingSlash) {
            return pathname + '/';
        }
        else if (action === 'remove' && hasTrailingSlash && pathname.length > 1) {
            return pathname.slice(0, -1);
        }
        return pathname;
    }

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    // See https://stackoverflow.com/questions/30402287/extended-errors-do-not-have-message-or-stack-trace
    var NaviError = /** @class */ (function (_super) {
        __extends(NaviError, _super);
        function NaviError(message) {
            var _newTarget = this.constructor;
            var _this = this;
            var trueProto = _newTarget.prototype;
            _this = _super.call(this, message) || this;
            _this.__proto__ = trueProto;
            if (Error.hasOwnProperty('captureStackTrace'))
                Error.captureStackTrace(_this, _this.constructor);
            else
                Object.defineProperty(_this, 'stack', {
                    value: (new Error()).stack
                });
            Object.defineProperty(_this, 'message', {
                value: message
            });
            return _this;
        }
        return NaviError;
    }(Error));
    var NotFoundError = /** @class */ (function (_super) {
        __extends(NotFoundError, _super);
        function NotFoundError(pathname) {
            var _this = _super.call(this, "URL not found: " + pathname) || this;
            // If you create a NotFoundError without a pathname, the
            // resolver will catch it and assign the correct pathname.
            _this.pathname = pathname;
            _this.status = 404;
            _this.name = 'NotFoundError';
            return _this;
        }
        return NotFoundError;
    }(NaviError));
    var OutOfRootError = /** @class */ (function (_super) {
        __extends(OutOfRootError, _super);
        function OutOfRootError(url) {
            var _this = _super.call(this, "URL not managed by router: " + url.href) || this;
            _this.url = url;
            _this.name = 'OutOfRootError';
            return _this;
        }
        return OutOfRootError;
    }(NaviError));

    function createChunk(type, request, details) {
        return Object.assign({
            type: type,
            request: request,
            url: createURLDescriptor({
                pathname: request.mountpath,
                query: request.query,
            }),
        }, details);
    }
    function createNotFoundChunk(request) {
        var fullPathname = joinPaths(request.mountpath, request.path);
        return {
            type: 'error',
            request: request,
            url: createURLDescriptor({
                pathname: fullPathname,
                query: request.query,
            }),
            error: new NotFoundError(fullPathname),
        };
    }

    var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __values = (undefined && undefined.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    function resolveChunks(maybeResolvable, request, createChunks) {
        var resolvable, maybeValue, result, promise, unwrappedPromise, busyChunks, error;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    resolvable = typeof maybeResolvable === 'function'
                        ? maybeResolvable
                        : function () { return maybeResolvable; };
                    try {
                        maybeValue = resolvable(request, request.context);
                    }
                    catch (e) {
                        maybeValue = Promise.reject(e);
                    }
                    if (!!isPromiseLike(maybeValue)) return [3 /*break*/, 1];
                    result = createChunks(maybeValue);
                    return [3 /*break*/, 7];
                case 1:
                    promise = maybeValue.then(extractDefault);
                    unwrappedPromise = unwrapPromise(promise);
                    busyChunks = [createChunk('busy', request, { promise: promise })];
                    _a.label = 2;
                case 2:
                    if (!!unwrappedPromise.outcome) return [3 /*break*/, 4];
                    return [4 /*yield*/, busyChunks];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 2];
                case 4:
                    if (!(unwrappedPromise.outcome === 'rejected')) return [3 /*break*/, 6];
                    error = unwrappedPromise.error;
                    if (error instanceof NotFoundError && !error.pathname) {
                        error.pathname = joinPaths(request.mountpath, request.path);
                    }
                    return [4 /*yield*/, [createChunk('error', request, { error: error })]];
                case 5:
                    _a.sent();
                    return [3 /*break*/, 7];
                case 6:
                    result = createChunks(unwrappedPromise.value);
                    _a.label = 7;
                case 7:
                    if (!result) return [3 /*break*/, 11];
                    if (!Array.isArray(result)) return [3 /*break*/, 9];
                    return [4 /*yield*/, result.length ? result : []];
                case 8:
                    _a.sent();
                    return [3 /*break*/, 11];
                case 9: return [5 /*yield**/, __values(result)];
                case 10:
                    _a.sent();
                    _a.label = 11;
                case 11: return [2 /*return*/];
            }
        });
    }
    function unwrapPromise(promise) {
        var result = {};
        promise.then(function (value) {
            result.value = value;
            result.outcome = 'resolved';
        }, function (error) {
            result.error = error;
            result.outcome = 'rejected';
        });
        return result;
    }
    // Not all promise libraries use the ES6 `Promise` constructor,
    // so there isn't a better way to check if it's a promise :-(
    function isPromiseLike(x) {
        return !!x && !!x['then'];
    }
    function extractDefault(value) {
        if (hasDefault(value)) {
            return value.default;
        }
        else {
            return value;
        }
    }
    function hasDefault(value) {
        return value && typeof value === 'object' && 'default' in value;
    }

    var __generator$1 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    function createMatcherIterator(matcherGenerator, request, pattern) {
        if (pattern === void 0) { pattern = ''; }
        {
            if (typeof matcherGenerator !== 'function') {
                console.error("A matcher at the URL \"" + joinPaths(request.mountpath, pattern) + "\" is invalid. A generator function was expected, but \"" + String(matcherGenerator) + "\" was received.");
            }
        }
        return matcherGenerator(request);
    }
    function concatMatcherIterators(x, y) {
        var xResult, yResult, xChunks, yChunks;
        return __generator$1(this, function (_a) {
            switch (_a.label) {
                case 0:
                    xChunks = [];
                    yChunks = [];
                    _a.label = 1;
                case 1:
                    xResult = x.next();
                    if (!xResult.done) {
                        xChunks = xResult.value || [];
                    }
                    yResult = y.next();
                    if (!yResult.done) {
                        yChunks = yResult.value || [];
                    }
                    return [4 /*yield*/, xChunks.concat(yChunks)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    if (!xResult.done || !yResult.done) return [3 /*break*/, 1];
                    _a.label = 4;
                case 4: return [2 /*return*/];
            }
        });
    }

    var __generator$2 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __values$1 = (undefined && undefined.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    function map(resolvableMatcher) {
        return function (child) { return function mapMatcherGenerator(request) {
            return __generator$2(this, function (_a) {
                switch (_a.label) {
                    case 0: return [5 /*yield**/, __values$1(resolveChunks(resolvableMatcher, request, function (childMatcher) { return createMatcherIterator(childMatcher(child), request); }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }; };
    }

    var __assign = (undefined && undefined.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    var KEY_WILDCARD = '\0';
    function createRootMapping(matcher, rootPath) {
        if (rootPath === void 0) { rootPath = ''; }
        return rootPath !== ''
            ? createMapping(rootPath, matcher)
            : {
                pattern: rootPath,
                key: '',
                regExp: new RegExp(''),
                matcher: matcher,
            };
    }
    function createMapping(pattern, matcher) {
        var processedPattern = pattern;
        if (processedPattern.length > 1 && processedPattern.substr(-1) === '/') {
            {
                console.warn("The pattern \"" + pattern + "\" ends with the character '/', so it has been automatically removed. To avoid this warning, don't add a final \"/\" to patterns.");
            }
            processedPattern = processedPattern.substr(0, processedPattern.length - 1);
        }
        if (processedPattern[0] !== '/') {
            {
                console.warn("The pattern \"" + pattern + "\" does not start with the character '/', so it has been automatically added. To avoid this warning, make sure to add the leading \"/\" to all patterns.");
            }
            processedPattern = '/' + processedPattern;
        }
        if (/\/{2,}/.test(processedPattern)) {
            {
                console.warn("The pattern \"" + pattern + " has adjacent '/' characters, which have been combined into single '/' characters. To avoid this warning, don't use adjacent '/' characters within patterns.");
            }
            processedPattern = processedPattern.replace(/\/{2,}/g, '/');
        }
        if (processedPattern.length === 0) {
            throw new Error("You cannot use an empty string \"\" as a pattern!");
        }
        var parts = processedPattern.split('/').slice(1);
        var pathParams = [];
        var keyParts = [];
        var regExpParts = ['^'];
        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part.length > 1 && part[0] === ':') {
                pathParams.push(part.slice(1));
                keyParts.push(KEY_WILDCARD);
                regExpParts.push('([^/]+)');
            }
            else {
                keyParts.push(part);
                regExpParts.push(escapeRegExp(part));
            }
        }
        return {
            key: keyParts.join('/'),
            matcher: matcher,
            pattern: processedPattern,
            pathParamNames: pathParams.length ? pathParams : undefined,
            regExp: processedPattern === '/' ? /^\/$/ : new RegExp(regExpParts.join('/')),
        };
    }
    function matchAgainstPathname(request, mapping) {
        var match = mapping.regExp.exec(request.path || '/');
        if (!match) {
            return;
        }
        var matchedPathname = match[0];
        var unmatchedPath = request.path.slice(matchedPathname.length) || '';
        if (unmatchedPath.length && unmatchedPath[0] !== '/') {
            return;
        }
        // Set path params using RegExp match
        var params = request.params;
        if (mapping.pathParamNames) {
            params = __assign({}, request.params);
            for (var i = 0; i < mapping.pathParamNames.length; i++) {
                var paramName = mapping.pathParamNames[i];
                params[paramName] = match[i + 1];
            }
        }
        var mountpath = joinPaths(request.mountpath, matchedPathname) || '/';
        return __assign(__assign({}, request), { params: params,
            mountpath: mountpath, path: unmatchedPath, url: unmatchedPath + request.search });
    }
    // From http://stackoverflow.com/a/5306111/106302
    // Originally from http://simonwillison.net/2006/Jan/20/escape/ (dead link)
    function escapeRegExp(value) {
        return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
    }

    function concat(args) {
        return [].concat.apply([], args);
    }

    var __assign$1 = (undefined && undefined.__assign) || function () {
        __assign$1 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$1.apply(this, arguments);
    };
    var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$3 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __read$1 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function mount(paths) {
        if (!paths) {
            throw new Error("mount() must be supplied with a paths object.");
        }
        var patterns = Object.keys(paths);
        var nonWildcardPatterns = patterns.filter(function (pattern) { return pattern !== '*'; });
        {
            var invalidPaths = patterns.filter(function (pattern) { return typeof paths[pattern] !== 'function'; });
            if (invalidPaths.length > 0) {
                throw new TypeError("The given paths: " + invalidPaths.join(', ') + " are invalid. " +
                    "Their values should be matcher objects. See https://frontarm.com/navi/en/reference/matchers/");
            }
        }
        // Wildcards in PatternMap objects are null (\0) characters, so they'll
        // always be sorted to the top. As such, by sorting the patterns, the
        // most specific (i.e. without wildcard) will always be at the bottom.
        var mappings = nonWildcardPatterns
            .map(function (pattern) { return createMapping(pattern, paths[pattern]); })
            .sort(function (x, y) { return compareStrings(x.key, y.key); });
        return function (child) {
            return function mountMatcherGenerator(request) {
                var chunks, childIterators, childResults, childChunkLists, crawlRequests, crawler, crawling, crawlTuplesPromise, crawlTuples_1, error_1, i, mapping, childRequest, wildcardMatcher, i, childResult, foundChunks, i, childChunks;
                return __generator$3(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            childResults = [];
                            childChunkLists = [];
                            crawlRequests = [];
                            crawler = request.crawler;
                            crawling = crawler && (request.path === '' || request.path === '/');
                            if (!crawling) return [3 /*break*/, 5];
                            crawlTuplesPromise = createCrawlTuplesPromise(paths, crawler, request);
                            crawlTuplesPromise.then(function (x) { crawlTuples_1 = x; }, function (y) { return error_1 = y; });
                            _a.label = 1;
                        case 1: return [4 /*yield*/, [createChunk('busy', request, { promise: crawlTuplesPromise })]];
                        case 2:
                            _a.sent();
                            if (error_1) {
                                throw error_1;
                            }
                            _a.label = 3;
                        case 3:
                            if (!crawlTuples_1) return [3 /*break*/, 1];
                            _a.label = 4;
                        case 4:
                            childIterators = crawlTuples_1.map(function (_a, i) {
                                var _b = __read$1(_a, 2), matcher = _b[0], crawlItem = _b[1];
                                var crawlRequest = __assign$1(__assign$1({}, request), { mountpath: crawlItem.url.pathname, url: '', path: '' });
                                crawlRequests[i] = crawlRequest;
                                return createMatcherIterator(matcher(child), crawlRequest, crawlRequest.mountpath);
                            });
                            return [3 /*break*/, 6];
                        case 5:
                            // Start from the beginning and take the first result, as child mounts
                            // are sorted such that the first matching mount is the the most
                            // precise match (and we always want to use the most precise match).
                            for (i = mappings.length - 1; i >= 0; i--) {
                                mapping = mappings[i];
                                childRequest = matchAgainstPathname(request, mapping);
                                if (childRequest) {
                                    childIterators = [createMatcherIterator(mapping.matcher(child), childRequest, mapping.pattern)];
                                    // The first match is always the only match, as we don't allow
                                    // for ambiguous patterns.
                                    break;
                                }
                            }
                            // If no matches are found, default to the wildcard pattern (if it
                            // exists)
                            if (!childIterators) {
                                wildcardMatcher = paths['*'];
                                if (wildcardMatcher) {
                                    childIterators = [createMatcherIterator(wildcardMatcher(child), request, '*')];
                                }
                            }
                            _a.label = 6;
                        case 6:
                            if (childIterators) {
                                for (i = 0; i < childIterators.length; i++) {
                                    childResult = childResults[i];
                                    if (!childResult || !childResult.done) {
                                        childResult = childResults[i] = childIterators[i].next();
                                    }
                                    if (childResult && !childResult.done) {
                                        childChunkLists[i] = childResult.value;
                                    }
                                }
                            }
                            chunks = [createChunk('mount', request, { patterns: patterns })];
                            foundChunks = false;
                            for (i = 0; i < childResults.length; i++) {
                                childChunks = childChunkLists[i];
                                if (childChunks) {
                                    foundChunks = true;
                                    if (crawling && !childChunks.some(isMountChunk)) {
                                        chunks = chunks.concat(createChunk('crawl', crawlRequests[i]));
                                    }
                                    chunks = chunks.concat(childChunks);
                                }
                            }
                            if (!crawler && !foundChunks) {
                                chunks.push(createNotFoundChunk(request));
                            }
                            return [4 /*yield*/, chunks];
                        case 7:
                            _a.sent();
                            _a.label = 8;
                        case 8:
                            if (chunks.filter(isBusy).length) return [3 /*break*/, 6];
                            _a.label = 9;
                        case 9: return [2 /*return*/];
                    }
                });
            };
        };
    }
    function compareStrings(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }
    function isBusy(chunk) {
        return chunk.type === 'busy';
    }
    function createCrawlTuplesPromise(paths, crawler, parentRequest) {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator$3(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = concat;
                        return [4 /*yield*/, Promise.all(Object.entries(paths).map(function (_a) {
                                var _b = __read$1(_a, 2), pattern = _b[0], matcher = _b[1];
                                return crawler(pattern === '*' ? '' : pattern, parentRequest).then(createTuplesWith(matcher));
                            }))];
                    case 1: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];
                }
            });
        });
    }
    function createTuplesWith(x) {
        return function (ys) { return ys.map(function (y) { return [x, y]; }); };
    }
    function isMountChunk(chunk) {
        return chunk.type === 'mount';
    }

    var __generator$4 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __values$2 = (undefined && undefined.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    function createChunksMatcher(maybeResolvable, forceChildMatcher, getChunks, exact, processDuringCrawl, predicate) {
        function chunksMatcherGenerator(request, child) {
            var unmatchedPathnamePart, parentIterator;
            return __generator$4(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        unmatchedPathnamePart = request.path;
                        if (!((exact === undefined ? !child : exact) && unmatchedPathnamePart && unmatchedPathnamePart !== '/')) return [3 /*break*/, 2];
                        return [4 /*yield*/, [createNotFoundChunk(request)]];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 2:
                        parentIterator = ((request.crawler && !processDuringCrawl) || (predicate && !predicate(request)))
                            ? empty()
                            : resolveChunks(maybeResolvable, request, function (value) { return getChunks(value, request); });
                        return [5 /*yield**/, __values$2((child ? concatMatcherIterators(parentIterator, createMatcherIterator(child, request)) : parentIterator))];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        }
        return (function (childGenerator) { return function (request) {
            return chunksMatcherGenerator(request, forceChildMatcher ? forceChildMatcher(childGenerator) : childGenerator);
        }; });
    }
    function empty() {
        return __generator$4(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, []];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }

    function redirect(maybeResolvableTo, _a) {
        var _b = (_a === void 0 ? {} : _a).exact, exact = _b === void 0 ? true : _b;
        return createChunksMatcher(maybeResolvableTo, undefined, function (to, request) {
            var toHref;
            if (typeof to === 'string') {
                toHref = to[0] === '/' ? to : joinPaths('/', request.mountpath, to);
            }
            else if (to) {
                toHref = createURLDescriptor(to).href;
            }
            return toHref ? [createChunk('redirect', request, { to: toHref })] : [];
        }, exact, true // proccess during crawl
        );
    }

    // Copyright (c) 2015-present Dan Abramov
    // The MIT License (MIT)
    // See: https://github.com/reduxjs/redux/blob/d53364c44b2fb75b59e2c98090b253c103d63c75/index.d.ts
    var __read$2 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var __spread$1 = (undefined && undefined.__spread) || function () {
        for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read$2(arguments[i]));
        return ar;
    };
    /**
     * Composes single-argument functions from right to left. The rightmost
     * function can take multiple arguments as it provides the signature for
     * the resulting composite function.
     *
     * @param {...Function} funcs The functions to compose.
     * @returns {Function} A function obtained by composing the argument functions
     * from right to left. For example, compose(f, g, h) is identical to doing
     * (...args) => f(g(h(...args))).
     */
    function compose() {
        var funcs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            funcs[_i] = arguments[_i];
        }
        if (funcs.length === 0) {
            throw new Error('composeMatchers() expects at least one matcher.');
        }
        if (funcs.length === 1) {
            return funcs[0];
        }
        return funcs.reduce(function (a, b) { return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return a(b.apply(void 0, __spread$1(args)));
        }; });
    }

    var __assign$2 = (undefined && undefined.__assign) || function () {
        __assign$2 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$2.apply(this, arguments);
    };
    var __generator$5 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __values$3 = (undefined && undefined.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    function withContext(childContextMaybeResolvable, forceChild) {
        {
            if (childContextMaybeResolvable === undefined) {
                console.warn("The first argument to withContext() should be the child context, but it was undefined. If you want to define an empty context, instead pass null.");
            }
        }
        function contextMatcherGenerator(request, child) {
            return __generator$5(this, function (_a) {
                switch (_a.label) {
                    case 0: return [5 /*yield**/, __values$3(resolveChunks(childContextMaybeResolvable, request, function (childContext) {
                            return createMatcherIterator(child, __assign$2(__assign$2({}, request), { context: childContext || {} }));
                        }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }
        return function (child) { return function (request) {
            return contextMatcherGenerator(request, forceChild ? forceChild(child) : child);
        }; };
    }

    function withData(maybeResolvableData, child) {
        return createChunksMatcher(maybeResolvableData, child, function (data, request) { return (data ? [createChunk('data', request, { data: data })] : []); });
    }

    function withHead(maybeResolvableHead, child) {
        return createChunksMatcher(maybeResolvableHead, child, function (head, request) { return head ? [createChunk('head', request, { head: head })] : []; });
    }

    function withHeaders(maybeResolvableHeaders, child) {
        return createChunksMatcher(maybeResolvableHeaders, child, function (headers, request) {
            return headers ? [createChunk('headers', request, { headers: headers })] : [];
        });
    }

    var __assign$3 = (undefined && undefined.__assign) || function () {
        __assign$3 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$3.apply(this, arguments);
    };
    var __generator$6 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __values$4 = (undefined && undefined.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    function withState(stateMaybeResolvable, forceChild) {
        {
            if (stateMaybeResolvable === undefined) {
                console.warn("The first argument to withState() should be the state resolver function, but it was undefined.");
            }
        }
        function stateMatcherGenerator(request, child) {
            return __generator$6(this, function (_a) {
                switch (_a.label) {
                    case 0: return [5 /*yield**/, __values$4(resolveChunks(stateMaybeResolvable, request, function (mergeState) {
                            var state = mergeState === null ? request.state : __assign$3(__assign$3({}, request.state), mergeState);
                            return concatMatcherIterators(chunks(mergeState === null ? [] : [createChunk('state', request, { state: state })]), createMatcherIterator(child, __assign$3(__assign$3({}, request), { state: state })));
                        }))];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }
        return function (child) { return function (request) {
            return stateMatcherGenerator(request, forceChild ? forceChild(child) : child);
        }; };
    }
    function chunks(chunks) {
        return __generator$6(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, chunks];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }

    function withStatus(maybeResolvableStatus, child) {
        return createChunksMatcher(maybeResolvableStatus, child, function (status, request) {
            return status ? [createChunk('status', request, { status: status })] : [];
        });
    }

    function withView(maybeResolvableView, child, exact) {
        return createChunksMatcher(maybeResolvableView, child, (function (view, request) { return view ? [createChunk('view', request, { view: view })] : []; }), exact, false, function (request) { return request.method !== 'HEAD'; });
    }

    function withTitle(maybeResolvableTitle, child) {
        return createChunksMatcher(maybeResolvableTitle, child, function (title, request) {
            return title ? [createChunk('title', request, { title: title })] : [];
        });
    }

    var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$7 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __rest = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    var __read$3 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    function route(options) {
        if (options === void 0) { options = {}; }
        var contextGetter;
        if (typeof options === 'function') {
            contextGetter = options;
        }
        else {
            var data_1 = options.data, getData_1 = options.getData, error_1 = options.error, head_1 = options.head, getHead_1 = options.getHead, headers_1 = options.headers, getHeaders_1 = options.getHeaders, state_1 = options.state, getState_1 = options.getState, status_1 = options.status, getStatus_1 = options.getStatus, title_1 = options.title, getTitle_1 = options.getTitle, view_1 = options.view, getView_1 = options.getView, other = __rest(options, ["data", "getData", "error", "head", "getHead", "headers", "getHeaders", "state", "getState", "status", "getStatus", "title", "getTitle", "view", "getView"]);
            {
                var unknownKeys = Object.keys(other);
                if (unknownKeys.length) {
                    console.warn("route() received unknown options " + unknownKeys
                        .map(function (x) { return "\"" + x + "\""; })
                        .join(', ') + ".");
                }
            }
            contextGetter = function getRoute(req, context) {
                var _a;
                var _this = this;
                var _b = __read$3(extractValue(data_1, getData_1, req, context), 2), dataMaybePromise = _b[0], a = _b[1];
                if (!dataMaybePromise) {
                    dataMaybePromise = {};
                }
                else if (isPromiseLike(dataMaybePromise)) {
                    dataMaybePromise = dataMaybePromise.then(inputOrEmptyObject);
                }
                var _c = __read$3(extractValue(headers_1, getHeaders_1, req, context), 2), headersMaybePromise = _c[0], b = _c[1];
                var _d = __read$3(extractValue(state_1, getState_1, req, context), 2), stateMaybePromise = _d[0], c = _d[1];
                var _e = __read$3(extractValue(status_1, getStatus_1, req, context), 2), statusMaybePromise = _e[0], d = _e[1];
                var _f = __read$3(extractValue(title_1, getTitle_1, req, context), 2), titleMaybePromise = _f[0], e = _f[1];
                var _g = __read$3(extractValue(head_1, getHead_1, req, context), 2), headMaybePromise = _g[0], f = _g[1];
                var viewMaybePromise;
                var g;
                if (req.method !== 'HEAD') {
                    _a = __read$3(extractValue(view_1, getView_1, req, context), 2), viewMaybePromise = _a[0], g = _a[1];
                }
                // If anything is a promise, return a promise
                if (a || b || c || d || e || f || g) {
                    return (function () { return __awaiter$1(_this, void 0, void 0, function () {
                        var _a;
                        return __generator$7(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    _a = {};
                                    return [4 /*yield*/, dataMaybePromise];
                                case 1:
                                    _a.data = _b.sent(),
                                        _a.error = error_1;
                                    return [4 /*yield*/, headMaybePromise];
                                case 2:
                                    _a.head = _b.sent();
                                    return [4 /*yield*/, headersMaybePromise];
                                case 3:
                                    _a.headers = _b.sent();
                                    return [4 /*yield*/, stateMaybePromise];
                                case 4:
                                    _a.state = _b.sent();
                                    return [4 /*yield*/, statusMaybePromise];
                                case 5:
                                    _a.status = _b.sent();
                                    return [4 /*yield*/, titleMaybePromise];
                                case 6:
                                    _a.title = _b.sent();
                                    return [4 /*yield*/, viewMaybePromise];
                                case 7: return [2 /*return*/, (_a.view = _b.sent(),
                                        _a)];
                            }
                        });
                    }); })();
                }
                // If nothing is a promise, return a synchronous result
                else {
                    return {
                        data: dataMaybePromise,
                        error: error_1,
                        head: headMaybePromise,
                        headers: headersMaybePromise,
                        state: stateMaybePromise,
                        status: statusMaybePromise,
                        title: titleMaybePromise,
                        view: viewMaybePromise,
                    };
                }
            };
        }
        return compose(withContext(function (req, context) {
            return req.crawler ? {} : contextGetter(req, context);
        }), withData(function (req) { return req.context.data; }), withHead(function (req) { return req.context.head; }), withHeaders(function (req) { return req.context.headers; }), withState(function (req) { return req.context.state || null; }), withStatus(function (req) { return req.context.status; }), withTitle(function (req) { return req.context.title; }), withView(function (req) { return req.context.view; }, undefined, true), createChunksMatcher(function (req) { return req.context.error; }, undefined, function (error, request) { return (error ? [createChunk('error', request, { error: error })] : []); }));
    }
    function inputOrEmptyObject(x) {
        return x || {};
    }
    function extractValue(value, getter, request, context) {
        if (getter) {
            var valueOrPromise = getter(request, context);
            if (isPromiseLike(valueOrPromise)) {
                return [valueOrPromise.then(extractDefault), true];
            }
            return [valueOrPromise, false];
        }
        else {
            return [value, false];
        }
    }

    var __assign$4 = (undefined && undefined.__assign) || function () {
        __assign$4 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$4.apply(this, arguments);
    };
    var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$8 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __values$5 = (undefined && undefined.__values) || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    function withCrawlerPatterns(crawlablePatterns, forceChild) {
        var _this = this;
        var crawlerResolvable = function (request) {
            return function (pattern, parentRequest) { return __awaiter$2(_this, void 0, void 0, function () {
                var expander, expansions, _a, _b;
                return __generator$8(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            expander = crawlablePatterns[pattern];
                            if (!(parentRequest.mountpath !== request.mountpath || !expander)) return [3 /*break*/, 1];
                            return [2 /*return*/, request.crawler(pattern, parentRequest)];
                        case 1:
                            if (!Array.isArray(expander)) return [3 /*break*/, 2];
                            _a = expander;
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, expander(request, request.context)];
                        case 3:
                            _a = _c.sent();
                            _c.label = 4;
                        case 4:
                            expansions = _a;
                            _b = concat;
                            return [4 /*yield*/, Promise.all(expansions.map(function (pattern) { return request.crawler(pattern, parentRequest); }))];
                        case 5: return [2 /*return*/, _b.apply(void 0, [_c.sent()])];
                    }
                });
            }); };
        };
        function contextMatcherGenerator(request, child) {
            return __generator$8(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!!request.crawler) return [3 /*break*/, 2];
                        return [5 /*yield**/, __values$5(createMatcherIterator(child, request))];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 4];
                    case 2: return [5 /*yield**/, __values$5(resolveChunks(crawlerResolvable, request, function (crawler) {
                            return createMatcherIterator(child, __assign$4(__assign$4({}, request), { crawler: crawler }));
                        }))];
                    case 3:
                        _a.sent();
                        _a.label = 4;
                    case 4: return [2 /*return*/];
                }
            });
        }
        return function (child) { return function (request) {
            return contextMatcherGenerator(request, forceChild ? forceChild(child) : child);
        }; };
    }

    var SimpleSubscription = /** @class */ (function () {
        function SimpleSubscription(close, observer) {
            this.close = close;
            this.observer = observer;
            if (this.observer.start) {
                this.observer.start(this);
            }
        }
        SimpleSubscription.prototype.unsubscribe = function () {
            if (!this.closed) {
                this.closed = true;
                this.close(this.observer);
                delete this.close;
                delete this.observer;
            }
        };
        return SimpleSubscription;
    }());
    function createOrPassthroughObserver(onNextOrObserver, onError, onComplete) {
        return (typeof onNextOrObserver === 'function'
            ? {
                next: onNextOrObserver,
                error: onError,
                complete: onComplete,
            }
            : onNextOrObserver);
    }
    function createPromiseFromObservable(observable) {
        return new Promise(function (resolve, reject) {
            observable.subscribe({
                start: function (subscription) {
                    this.subscription = subscription;
                },
                next: function (value) {
                    this.value = value;
                },
                complete: function () {
                    resolve(this.value);
                    this.subscription.unsubscribe();
                },
                error: function (e) {
                    reject(e);
                    this.subscription.unsubscribe();
                }
            });
        });
    }

    var ChunkListObservable = /** @class */ (function () {
        function ChunkListObservable(url, request, matcherGenerator) {
            var _this = this;
            this.handleUnsubscribe = function (observer) {
                var index = _this.observers.indexOf(observer);
                if (index !== -1) {
                    _this.observers.splice(index, 1);
                }
            };
            this.handleChange = function (listenId) {
                if (listenId === _this.lastListenId) {
                    _this.lastListenId++;
                    _this.refresh();
                    var isDone = _this.result.done || _this.result.value.every(function (chunk) { return chunk.type !== 'busy'; });
                    for (var i = 0; i < _this.observers.length; i++) {
                        var observer = _this.observers[i];
                        observer.next(_this.result.value);
                        if (isDone && observer.complete) {
                            observer.complete();
                        }
                    }
                    if (isDone) {
                        delete _this.matcherIterator;
                    }
                }
            };
            this.refresh = function () {
                var result = _this.matcherIterator.next();
                if (result.value) {
                    _this.result = result;
                }
                if (!_this.result.done) {
                    var listenId_1 = ++_this.lastListenId;
                    var handleUpdate = function () { return _this.handleChange(listenId_1); };
                    Promise.race(_this.result.value
                        .filter(isBusy$1)
                        .map(pickChunkPromise)).then(handleUpdate, handleUpdate);
                }
            };
            this.url = url;
            this.lastListenId = 0;
            this.observers = [];
            this.matcherIterator = matcherGenerator(request);
        }
        ChunkListObservable.prototype.subscribe = function (onNextOrObserver, onError, onComplete) {
            if (!this.matcherIterator) {
                throw new Error("Can't subscribe to an already-complete RoutingObservable.");
            }
            var observer = createOrPassthroughObserver(onNextOrObserver, onError, onComplete);
            this.observers.push(observer);
            var subscription = new SimpleSubscription(this.handleUnsubscribe, observer);
            if (this.observers.length === 1) {
                this.handleChange(this.lastListenId);
            }
            return subscription;
        };
        return ChunkListObservable;
    }());
    function isBusy$1(chunk) {
        return chunk.type === 'busy';
    }
    function pickChunkPromise(chunk) {
        return chunk.promise;
    }

    var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$9 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __read$4 = (undefined && undefined.__read) || function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };
    var ChunksMapObservable = /** @class */ (function () {
        function ChunksMapObservable(url, rootContext, matcherGeneratorClass, rootMapping, router, options) {
            var _this = this;
            this.handleUnsubscribe = function (observer) {
                var index = _this.observers.indexOf(observer);
                if (index !== -1) {
                    _this.observers.splice(index, 1);
                }
            };
            this.handleResolverUpdate = function (listenId) {
                if (listenId === _this.lastListenId) {
                    _this.lastListenId++;
                    if (!_this.isRefreshing) {
                        _this.refresh();
                    }
                    else if (!_this.isRefreshScheduled) {
                        _this.isRefreshScheduled = true;
                    }
                }
            };
            this.refresh = function () { return __awaiter$3(_this, void 0, void 0, function () {
                var allChunks, i, _loop_1, this_1, state_1, chunksMapArray, i_1, item, lastChunk, listenId, handleUpdate, chunksMap, isSteady, i_2, _a, pathname, chunks, i_3, observer;
                var _this = this;
                return __generator$9(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            this.isRefreshScheduled = false;
                            this.isRefreshing = true;
                            allChunks = [];
                            i = 0;
                            _loop_1 = function () {
                                var item, pathname, result, chunks, focusIndex, focusChunk, patterns, key, j, expandedPatterns, k;
                                return __generator$9(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            item = this_1.mapItems[i];
                                            pathname = item.pathname;
                                            result = item.matcherIterator.next();
                                            if (!item.lastResult || result.value) {
                                                item.lastResult = result;
                                            }
                                            chunks = item.lastResult.value;
                                            item.chunksCache = chunks || [];
                                            focusIndex = chunks.findIndex(function (chunk) {
                                                return chunk.type === 'error' ||
                                                    (chunk.url.href.length >= item.url.href.length &&
                                                        ((chunk.type === 'mount' &&
                                                            item.lastMountPatterns !== chunk.patterns) ||
                                                            (chunk.type === 'redirect' && item.lastRedirectTo !== chunk.to)));
                                            });
                                            _a.label = 1;
                                        case 1:
                                            if (!(focusIndex >= 0 && focusIndex < chunks.length)) return [3 /*break*/, 6];
                                            focusChunk = chunks[focusIndex];
                                            focusIndex++;
                                            // If an item in the map cannot be found, throws an error, or is
                                            // no longer referenced by other items, then remove it from the
                                            // map.
                                            //
                                            // Note that later items in the map should always be "from" earlier
                                            // items, so if an earlier item is removed, its referenced items
                                            // will still be removed.
                                            if (focusChunk.type === 'error' ||
                                                (this_1.options.predicate &&
                                                    !this_1.options.predicate(focusChunk, chunks))) {
                                                this_1.removeFromQueue(item);
                                                return [2 /*return*/, "continue-items"];
                                            }
                                            if (focusChunk.type === 'redirect') {
                                                item.lastRedirectTo = focusChunk.to;
                                                if (this_1.options.followRedirects) {
                                                    this_1.addToQueue(focusChunk.to, item.depth + 1, item.walkedPatternLists, pathname, item.order);
                                                }
                                            }
                                            if (!(focusChunk.type === 'mount')) return [3 /*break*/, 5];
                                            patterns = focusChunk.patterns;
                                            item.lastMountPatterns = patterns;
                                            key = patterns
                                                .slice(0)
                                                .sort()
                                                .join('\n');
                                            if (!(patterns && !item.walkedPatternLists.has(key))) return [3 /*break*/, 5];
                                            item.walkedPatternLists.add(key);
                                            j = 0;
                                            _a.label = 2;
                                        case 2:
                                            if (!(j < patterns.length)) return [3 /*break*/, 5];
                                            return [4 /*yield*/, this_1.expandPatterns(joinPaths(pathname, patterns[j]))];
                                        case 3:
                                            expandedPatterns = _a.sent();
                                            for (k = 0; k < expandedPatterns.length; k++) {
                                                this_1.addToQueue(expandedPatterns[k], item.depth + 1, item.walkedPatternLists, pathname, item.order.concat(j, k));
                                            }
                                            _a.label = 4;
                                        case 4:
                                            j++;
                                            return [3 /*break*/, 2];
                                        case 5: return [3 /*break*/, 1];
                                        case 6:
                                            if (chunks) {
                                                allChunks = allChunks.concat(chunks);
                                            }
                                            // Increment at the end of the loop in case the current item has
                                            // been removed, in which case the index won't change.
                                            i++;
                                            return [2 /*return*/];
                                    }
                                });
                            };
                            this_1 = this;
                            _b.label = 1;
                        case 1:
                            if (!(this.mapItems && i < this.mapItems.length)) return [3 /*break*/, 3];
                            return [5 /*yield**/, _loop_1()];
                        case 2:
                            state_1 = _b.sent();
                            switch (state_1) {
                                case "continue-items": return [3 /*break*/, 1];
                            }
                            return [3 /*break*/, 1];
                        case 3:
                            // It's possible for the map to finish while waiting for expandPatterns to return.
                            if (!this.mapItems) {
                                return [2 /*return*/];
                            }
                            chunksMapArray = [];
                            for (i_1 = 0; i_1 < this.mapItems.length; i_1++) {
                                item = this.mapItems[i_1];
                                lastChunk = item.chunksCache[item.chunksCache.length - 1];
                                if (lastChunk.type !== 'mount' &&
                                    lastChunk.type !== 'error' &&
                                    (lastChunk.type === 'busy' ||
                                        !this.options.predicate ||
                                        this.options.predicate(lastChunk, item.chunksCache))) {
                                    chunksMapArray.push([
                                        joinPaths(item.pathname, '/'),
                                        item.chunksCache,
                                        item.order,
                                    ]);
                                }
                            }
                            listenId = ++this.lastListenId;
                            handleUpdate = function () { return _this.handleResolverUpdate(listenId); };
                            Promise.race(allChunks.filter(isBusy$2).map(pickChunkPromise$1)).then(handleUpdate, handleUpdate);
                            chunksMapArray.sort(function (itemX, itemY) {
                                var x = itemX[2];
                                var y = itemY[2];
                                if (x.length < y.length) {
                                    return -1;
                                }
                                if (x.length > y.length) {
                                    return 1;
                                }
                                for (var i_4 = 0; i_4 < x.length; i_4++) {
                                    if (x[i_4] < y[i_4]) {
                                        return -1;
                                    }
                                    if (x[i_4] > y[i_4]) {
                                        return 1;
                                    }
                                }
                                return 0;
                            });
                            if (this.isRefreshScheduled) {
                                this.refresh();
                            }
                            else {
                                chunksMap = {};
                                isSteady = true;
                                for (i_2 = 0; i_2 < chunksMapArray.length; i_2++) {
                                    _a = __read$4(chunksMapArray[i_2], 2), pathname = _a[0], chunks = _a[1];
                                    if (chunks.some(function (chunk) { return chunk.type === 'busy'; })) {
                                        isSteady = false;
                                    }
                                    chunksMap[modifyTrailingSlash(pathname, 'remove')] = chunks;
                                }
                                for (i_3 = 0; i_3 < this.observers.length; i_3++) {
                                    observer = this.observers[i_3];
                                    observer.next(chunksMap);
                                    if (isSteady && observer.complete) {
                                        observer.complete();
                                    }
                                }
                                if (isSteady) {
                                    delete this.rootContext;
                                    delete this.mapItems;
                                    delete this.router;
                                    delete this.observers;
                                }
                                this.isRefreshing = false;
                            }
                            return [2 /*return*/];
                    }
                });
            }); };
            this.observers = [];
            this.lastListenId = 0;
            this.mapItems = [];
            this.router = router;
            this.rootContext = rootContext;
            this.matcherGeneratorFunction = matcherGeneratorClass;
            this.rootMapping = rootMapping;
            this.options = options;
            this.seenPathnames = new Set();
            var pathname = url.pathname;
            // A final '/' always indicates a Page or Redirect, and it
            // doesn't really make sense to build a map of a single page/redirect.
            if (pathname.substr(-1) === '/') {
                pathname = pathname.substr(0, pathname.length - 1);
            }
            this.addToQueue(pathname, 0, new Set());
        }
        ChunksMapObservable.prototype.subscribe = function (onNextOrObserver, onError, onComplete) {
            if (!this.observers) {
                throw new Error("Can't subscribe to an already-complete RoutingObservable.");
            }
            var observer = createOrPassthroughObserver(onNextOrObserver, onError, onComplete);
            this.observers.push(observer);
            var subscription = new SimpleSubscription(this.handleUnsubscribe, observer);
            if (this.observers.length === 1) {
                this.refresh();
            }
            return subscription;
        };
        ChunksMapObservable.prototype.expandPatterns = function (pattern) {
            return __awaiter$3(this, void 0, void 0, function () {
                var expandedPatterns;
                return __generator$9(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.options.expandPattern) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.options.expandPattern(pattern, this.router)];
                        case 1:
                            expandedPatterns = _a.sent();
                            if (expandedPatterns) {
                                return [2 /*return*/, expandedPatterns];
                            }
                            _a.label = 2;
                        case 2: return [2 /*return*/, [pattern].filter(function (pattern) { return !/\/:/.test(pattern); })];
                    }
                });
            });
        };
        ChunksMapObservable.prototype.removeFromQueue = function (item) {
            var i = this.mapItems.indexOf(item);
            if (i !== -1) {
                this.mapItems.splice(i, 1);
            }
        };
        ChunksMapObservable.prototype.addToQueue = function (pathname, depth, walkedPatternLists, fromPathname, order) {
            if (order === void 0) { order = [0]; }
            if (this.seenPathnames.has(pathname)) {
                return;
            }
            if (!this.options.maxDepth || depth <= this.options.maxDepth) {
                this.seenPathnames.add(pathname);
                var url = createURLDescriptor(pathname, {
                    removeHash: true,
                });
                var request = {
                    body: null,
                    context: this.rootContext,
                    headers: this.options.headers || {},
                    method: this.options.method || 'HEAD',
                    params: {},
                    hostname: this.options.hostname || '',
                    mountpath: '',
                    query: url.query,
                    search: url.search,
                    hash: url.hash,
                    path: url.pathname,
                    url: url.pathname + url.search,
                    originalUrl: url.href,
                    state: {},
                };
                var matchRequest = matchAgainstPathname(request, this.rootMapping);
                if (matchRequest) {
                    this.mapItems.push({
                        url: url,
                        fromPathname: fromPathname,
                        depth: depth,
                        pathname: pathname,
                        order: order,
                        walkedPatternLists: new Set(walkedPatternLists),
                        matcherIterator: this.matcherGeneratorFunction(matchRequest),
                    });
                }
            }
        };
        return ChunksMapObservable;
    }());
    function isBusy$2(chunk) {
        return chunk.type === 'busy';
    }
    function pickChunkPromise$1(chunk) {
        return chunk.promise;
    }

    var __assign$5 = (undefined && undefined.__assign) || function () {
        __assign$5 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$5.apply(this, arguments);
    };
    function routeReducer(route, chunk) {
        if (route) {
            if (chunk.type === 'url') {
                return __assign$5(__assign$5({}, route), { chunks: route.chunks.filter(function (chunk) { return chunk.type !== 'url'; }), url: chunk.url });
            }
            if (route.type !== 'ready') {
                return route;
            }
        }
        var base = {
            lastChunk: chunk,
            method: (chunk.request && chunk.request.method),
            chunks: route ? route.chunks.concat(chunk) : [chunk],
            data: route ? route.data : {},
            headers: route ? route.headers : {},
            heads: route ? route.heads : [],
            state: route ? route.state : {},
            status: route ? route.status : 200,
            title: route && route.title,
            url: route ? route.url : chunk.url,
            views: route ? route.views : [],
        };
        switch (chunk.type) {
            case 'busy':
                return __assign$5(__assign$5({}, base), { type: 'busy' });
            case 'data':
                return __assign$5(__assign$5({}, base), { type: 'ready', data: __assign$5(__assign$5({}, base.data), chunk.data) });
            case 'error':
                return __assign$5(__assign$5({}, base), { type: 'error', error: chunk.error, status: base.status && base.status >= 400
                        ? base.status
                        : chunk.error.status || 500 });
            case 'head':
                return __assign$5(__assign$5({}, base), { type: 'ready', heads: base.heads.concat(chunk.head) });
            case 'headers':
                return __assign$5(__assign$5({}, base), { type: 'ready', headers: __assign$5(__assign$5({}, base.headers), chunk.headers) });
            case 'redirect':
                return __assign$5(__assign$5({}, base), { type: 'redirect', to: chunk.to });
            case 'state':
                return __assign$5(__assign$5({}, base), { type: 'ready', state: __assign$5(__assign$5({}, base.state), chunk.state) });
            case 'status':
                return __assign$5(__assign$5({}, base), { type: 'ready', status: chunk.status });
            case 'title':
                return __assign$5(__assign$5({}, base), { type: 'ready', title: chunk.title });
            case 'view':
                return __assign$5(__assign$5({}, base), { type: 'ready', views: base.views.concat(chunk.view) });
            default:
                return __assign$5(__assign$5({}, base), { type: 'ready' });
        }
    }

    function createRouter(options) {
        return new Router(options);
    }
    var Router = /** @class */ (function () {
        function Router(options) {
            this.context = options.context || {};
            this.matcherGenerator = options.routes();
            var basename = options.basename;
            if (basename && basename.slice(-1) === '/') {
                basename = basename.slice(0, -1);
            }
            this.rootMapping = createRootMapping(options.routes, basename);
        }
        // Please don't document this API. It should only be used through
        // "createBrowserNavigation()" or "createMemoryNavigation()"
        Router.prototype.setContext = function (context) {
            this.context = context || {};
        };
        Router.prototype.createObservable = function (url, options) {
            var request = {
                body: options.body,
                context: this.context,
                headers: options.headers || {},
                method: options.method || 'GET',
                hostname: url.hostname,
                hash: url.hash,
                mountpath: '/',
                params: url.query,
                query: url.query,
                search: url.search,
                url: url.pathname + url.search,
                originalUrl: url.href,
                path: url.pathname,
                crawler: options.crawler,
                state: options.state || {},
            };
            var matchRequest = matchAgainstPathname(request, this.rootMapping);
            if (matchRequest) {
                return new ChunkListObservable(url, matchRequest, this.matcherGenerator);
            }
        };
        Router.prototype.createMapObservable = function (urlOrDescriptor, options) {
            if (options === void 0) { options = {}; }
            return new ChunksMapObservable(createURLDescriptor(urlOrDescriptor), this.context, this.matcherGenerator, this.rootMapping, this, options);
        };
        Router.prototype.resolve = function (urls, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var urlDescriptors;
            if (Array.isArray(urls)) {
                urlDescriptors = urls.map(function (url) { return createURLDescriptor(url); });
            }
            else if (typeof urls === 'string') {
                urlDescriptors = [createURLDescriptor(urls)];
            }
            else if (urls.url) {
                options = urls;
                urlDescriptors = [createURLDescriptor(options.url)];
            }
            else if (options) {
                urlDescriptors = [createURLDescriptor(urls)];
            }
            else {
                throw new Error("You must specify a URL for router.resolve().");
            }
            if (!urlDescriptors.length) {
                return Promise.resolve([]);
            }
            var promises = urlDescriptors.map(function (url) {
                return _this.getPageRoutePromise(url, options);
            });
            return !Array.isArray(urls) ? promises[0] : Promise.all(promises);
        };
        Router.prototype.resolveSiteMap = function (urlOrDescriptor, options) {
            if (options === void 0) { options = {}; }
            return createPromiseFromObservable(this.createMapObservable(urlOrDescriptor, options)).then(function (chunksMap) {
                var routeMap = {};
                var redirectMap = {};
                var urls = Object.keys(chunksMap);
                for (var i = 0; i < urls.length; i++) {
                    var url = urls[i];
                    var chunks = chunksMap[url];
                    var lastChunk = chunks[chunks.length - 1];
                    if (lastChunk.type === 'redirect') {
                        redirectMap[url] = lastChunk.to;
                        continue;
                    }
                    else {
                        routeMap[url] = [{ type: 'url', url: createURLDescriptor(url) }]
                            .concat(chunks)
                            .reduce(routeReducer, undefined);
                    }
                }
                return {
                    routes: routeMap,
                    redirects: redirectMap,
                };
            });
        };
        Router.prototype.resolveRouteMap = function (urlOrDescriptor, options) {
            if (options === void 0) { options = {}; }
            return this.resolveSiteMap(urlOrDescriptor, options).then(function (siteMap) { return siteMap.routes; });
        };
        Router.prototype.getPageRoutePromise = function (url, options) {
            var _this = this;
            var observable = this.createObservable(url, options);
            if (!observable) {
                return Promise.reject(new OutOfRootError(url));
            }
            return createPromiseFromObservable(observable).then(function (chunks) {
                for (var i = 0; i < chunks.length; i++) {
                    var chunk = chunks[i];
                    if (chunk.type === 'busy') {
                        break;
                    }
                    if (chunk.type === 'redirect' && options.followRedirects) {
                        return _this.getPageRoutePromise(createURLDescriptor(chunk.to), options);
                    }
                    if (chunk.type === 'error') {
                        throw chunk.error;
                    }
                }
                return [{ type: 'url', url: createURLDescriptor(url) }]
                    .concat(chunks)
                    .reduce(routeReducer, undefined);
            });
        };
        return Router;
    }());

    var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$a = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    function crawl(options) {
        return __awaiter$4(this, void 0, void 0, function () {
            var router, url, predicate, expandPattern, crawler, chunkListObservable, chunkList, paths, redirects, i, chunk, pathname, j, subChunk;
            var _this = this;
            return __generator$a(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        router = createRouter({
                            basename: options.basename,
                            context: options.context,
                            routes: options.routes,
                        });
                        url = createURLDescriptor(options.root || '');
                        predicate = options.predicate || (function () { return true; });
                        expandPattern = options.expandPattern || (function (pattern) { return [pattern || '']; });
                        crawler = function (pattern, parentRequest) { return __awaiter$4(_this, void 0, void 0, function () {
                            var patterns;
                            return __generator$a(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, expandPattern(pattern)];
                                    case 1:
                                        patterns = (_a.sent()) || [];
                                        return [2 /*return*/, patterns
                                                .map(function (pattern) { return ({
                                                headers: parentRequest.headers,
                                                url: createURLDescriptor(joinPaths(parentRequest.mountpath, pattern)),
                                                context: parentRequest.headers,
                                            }); })
                                                .filter(predicate)];
                                }
                            });
                        }); };
                        chunkListObservable = router.createObservable(url, {
                            crawler: crawler,
                            headers: options.headers,
                            method: 'HEAD',
                        });
                        return [4 /*yield*/, createPromiseFromObservable(chunkListObservable)
                            // Build a list of pages and redirects from the list of chunks
                        ];
                    case 1:
                        chunkList = _a.sent();
                        paths = [];
                        redirects = {};
                        chunk: for (i = 0; i < chunkList.length; i++) {
                            chunk = chunkList[i];
                            if (chunk.type === 'crawl') {
                                pathname = chunk.url.pathname;
                                if (pathname.indexOf(':') !== -1) {
                                    continue;
                                }
                                for (j = i + 1; j < chunkList.length; j++, i++) {
                                    subChunk = chunkList[j];
                                    if (subChunk.type === 'crawl' || subChunk.type === 'mount') {
                                        break;
                                    }
                                    if (subChunk.type === 'redirect') {
                                        redirects[pathname] = subChunk.to;
                                        continue chunk;
                                    }
                                }
                                paths.push(pathname);
                            }
                        }
                        return [2 /*return*/, {
                                paths: options.trailingSlash !== null
                                    ? paths.map(function (path) { return modifyTrailingSlash(path, options.trailingSlash || 'remove'); })
                                    : paths,
                                redirects: redirects,
                            }];
                }
            });
        });
    }

    var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$b = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __rest$1 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    function resolve(options) {
        return __awaiter$5(this, void 0, void 0, function () {
            var basename, context, routes, url, urls, routerResolveOptions, router;
            return __generator$b(this, function (_a) {
                basename = options.basename, context = options.context, routes = options.routes, url = options.url, urls = options.urls, routerResolveOptions = __rest$1(options, ["basename", "context", "routes", "url", "urls"]);
                if (url && urls) {
                    throw new Error('You cannot pass both `url` and `urls` options to resolve(). Please pick one!');
                }
                if (!url && !urls) {
                    throw new Error('You must pass one of `url` or `urls` options to resolve().');
                }
                router = createRouter({
                    basename: basename,
                    context: context,
                    routes: routes,
                });
                return [2 /*return*/, router.resolve(url || urls, routerResolveOptions)];
            });
        });
    }

    var Deferred = /** @class */ (function () {
        function Deferred() {
            this.promise = new Promise(function (resolve, reject) {
                this.resolve = resolve;
                this.reject = reject;
            }.bind(this));
            Object.freeze(this);
        }
        return Deferred;
    }());

    var __assign$6 = (undefined && undefined.__assign) || function () {
        __assign$6 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$6.apply(this, arguments);
    };
    var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$c = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var __rest$2 = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };
    // Keep track of the number of navigations since the last steady route,
    // so we can detect and bail out of navigation loops.
    var MAX_NAVIGATIONS_SINCE_STEADY = 100;
    var Navigation = /** @class */ (function () {
        function Navigation(options) {
            var _this = this;
            this.handleUnsubscribe = function (observer) {
                var index = _this.observers.indexOf(observer);
                if (index !== -1) {
                    _this.observers.splice(index, 1);
                }
            };
            // Allows for either the location or route or both to be changed at once.
            this.handleChunkList = function (chunks) {
                var isSteady = true;
                var location = _this._history.location;
                for (var i = 0; i < chunks.length; i++) {
                    var chunk = chunks[i];
                    if (chunk.type === 'busy') {
                        isSteady = false;
                    }
                    if (chunk.type === 'state') {
                        _this.ignoreNextLocationChange = true;
                        _this._history.replace(__assign$6(__assign$6({}, location), { state: setLocationRequestState(location.state, chunk.state) }));
                    }
                    if (chunk.type === 'redirect') {
                        var revertedState = revertLocationState(location.state);
                        if (revertedState) {
                            _this.ignoreNextLocationChange = true;
                            _this._history.replace(__assign$6(__assign$6({}, location), { state: revertedState }));
                            _this._history.push(chunk.to);
                        }
                        else {
                            _this._history.replace(chunk.to);
                        }
                        return;
                    }
                }
                _this.setRoute([{ type: 'url', url: createURLDescriptor(_this.lastHandledLocation) }]
                    .concat(chunks)
                    .reduce(routeReducer, undefined), isSteady);
            };
            this._history = options.history;
            this.observers = [];
            this.isLastRouteSteady = false;
            this.navigationsSinceSteady = 0;
            this.basename = options.basename;
            this.matcher = options.routes;
            this._router = new Router({
                context: options.context,
                routes: options.routes,
                basename: options.basename,
            });
            this.trailingSlash =
                options.trailingSlash === undefined ? 'remove' : options.trailingSlash;
            this.unlisten = this._history.listen(function (location) {
                return _this.handleLocationChange(location, false);
            });
            this.navigate = this.navigate.bind(this);
        }
        Navigation.prototype.dispose = function () {
            this.observers.length = 0;
            this.unlisten();
            delete this.unlisten;
            delete this._history;
            if (this.observableSubscription) {
                this.observableSubscription.unsubscribe();
            }
            delete this.observableSubscription;
            delete this._router;
            delete this.waitUntilSteadyDeferred;
            delete this.lastRoute;
            delete this._router;
        };
        Navigation.prototype.go = function (n) {
            return __awaiter$6(this, void 0, void 0, function () {
                var urlChanged;
                var _this = this;
                return __generator$c(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            urlChanged = new Promise(function (resolve) {
                                var unlisten = _this._history.listen(function () {
                                    unlisten();
                                    resolve();
                                });
                            });
                            this._history.go(n);
                            return [4 /*yield*/, urlChanged];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, this.getRoute()];
                    }
                });
            });
        };
        Navigation.prototype.goBack = function () {
            return this.go(-1);
        };
        Navigation.prototype.goForward = function () {
            return this.go(1);
        };
        Navigation.prototype.navigate = function (url, options) {
            if (options === void 0) { options = {}; }
            var nextURL;
            if (typeof url === 'string') {
                nextURL = createURLDescriptor(url);
            }
            else if (url.url) {
                options = url;
                nextURL = createURLDescriptor(options.url);
            }
            else if (url) {
                nextURL = createURLDescriptor(url);
            }
            else {
                throw new Error("You must specify a URL or state to navigation.navigate().");
            }
            var currentLocation = this._history.location;
            // Default to replace when we're not changing the URL itself, but only
            // changing state.
            var shouldReplace = options.replace ||
                (options.replace !== false &&
                    currentLocation.pathname === nextURL.pathname &&
                    currentLocation.search === nextURL.search &&
                    currentLocation.hash === nextURL.hash);
            this._history[shouldReplace ? 'replace' : 'push']({
                pathname: nextURL.pathname,
                search: nextURL.search,
                hash: nextURL.hash,
                state: packLocationState({
                    revertTo: shouldReplace ? currentLocation.state : undefined,
                    method: options.method,
                    headers: options.headers,
                    body: options.body,
                    state: options.state,
                }),
            });
            return this.getRoute();
        };
        // TODO:
        // Put any history state on a "prefetched state" object, so that on
        // navigation, any prefetched state can be reused.
        Navigation.prototype.prefetch = function (url) {
            return __awaiter$6(this, void 0, void 0, function () {
                return __generator$c(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, resolve({
                                basename: this.basename,
                                routes: this.matcher,
                                context: this._router.context,
                                url: url,
                            })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        Navigation.prototype.refresh = function () {
            this.handleLocationChange(this._history.location, true);
            return this.getRoute();
        };
        Navigation.prototype.setContext = function (context) {
            this._router.setContext(context);
            return this.refresh();
        };
        /**
         * Get the latest Route object, regardless of whether it is loading.
         *
         * This is named as `getCurrentValue()` so that Navigation objects can be
         * used with React's `createSubscription()`, and other tools that follow
         * the same specification.
         */
        Navigation.prototype.getCurrentValue = function () {
            return this.lastRoute;
        };
        /**
         * If loading, returns a promise to the non-busy route. Otherwise, returns
         * the current route.
         */
        Navigation.prototype.getRoute = function () {
            return __awaiter$6(this, void 0, void 0, function () {
                return __generator$c(this, function (_a) {
                    if (this.isLastRouteSteady) {
                        return [2 /*return*/, this.lastRoute];
                    }
                    else if (!this.waitUntilSteadyDeferred) {
                        this.waitUntilSteadyDeferred = new Deferred();
                    }
                    return [2 /*return*/, this.waitUntilSteadyDeferred.promise];
                });
            });
        };
        /**
         * Returns the current history state
         */
        Navigation.prototype.extractState = function () {
            return this._history.location.state;
        };
        /**
         * If you're using code splitting, you'll need to subscribe to changes to
         * Route, as the route may change as new code chunks are received.
         */
        Navigation.prototype.subscribe = function (onNextOrObserver, onError, onComplete) {
            var observer = createOrPassthroughObserver(onNextOrObserver, onError, onComplete);
            this.observers.push(observer);
            return new SimpleSubscription(this.handleUnsubscribe, observer);
        };
        Navigation.prototype.handleLocationChange = function (location, force) {
            if (this.ignoreNextLocationChange) {
                this.ignoreNextLocationChange = false;
                return;
            }
            if (++this.navigationsSinceSteady > MAX_NAVIGATIONS_SINCE_STEADY) {
                console.error("Detected possible navigation loop with " + MAX_NAVIGATIONS_SINCE_STEADY + " navigations between steady routes. Bailing.");
                return;
            }
            // Ensure the pathname always has a trailing `/`, so that we don't
            // have multiple URLs referring to the same page.
            if (this.trailingSlash !== null) {
                var modifiedPathname = modifyTrailingSlash(location.pathname, this.trailingSlash);
                if (location.pathname !== modifiedPathname) {
                    this._history.replace(__assign$6(__assign$6({}, location), { pathname: modifiedPathname }));
                    return;
                }
            }
            var url = createURLDescriptor(location);
            var lastHandledLocation = this.lastHandledLocation;
            this.lastHandledLocation = location;
            if (this.observableSubscription) {
                this.observableSubscription.unsubscribe();
            }
            var observable = this._router.createObservable(url, unpackLocationState(location.state));
            if (observable) {
                this.observableSubscription = observable.subscribe(this.handleChunkList);
            }
            else if (!lastHandledLocation) {
                throw new OutOfRootError(url);
            }
        };
        Navigation.prototype.setRoute = function (route, isSteady) {
            if (route !== this.lastRoute) {
                this.lastRoute = route;
                this.isLastRouteSteady = isSteady;
                if (isSteady) {
                    this.navigationsSinceSteady = 0;
                }
                for (var i = 0; i < this.observers.length; i++) {
                    this.observers[i].next(route);
                }
                // Check this.isLastRouteSteady instead of isSteady, in case one of our
                // subscribers causes navigation again.
                if (this.isLastRouteSteady && this.waitUntilSteadyDeferred) {
                    this.waitUntilSteadyDeferred.resolve(route);
                    delete this.waitUntilSteadyDeferred;
                }
            }
        };
        return Navigation;
    }());
    var NAVI_STATE_KEY = '__navi__';
    /**
     * Set the value of request.state without changing the other request data.
     */
    function setLocationRequestState(locationState, newState) {
        var _a;
        if (locationState === void 0) { locationState = {}; }
        return __assign$6(__assign$6({}, newState), (_a = {}, _a[NAVI_STATE_KEY] = locationState[NAVI_STATE_KEY], _a));
    }
    function packLocationState(_a) {
        var _b;
        var revertTo = _a.revertTo, state = _a.state, requestDataWithoutState = __rest$2(_a, ["revertTo", "state"]);
        if (revertTo) {
            revertTo = __assign$6({}, revertTo);
            if (revertTo[NAVI_STATE_KEY]) {
                delete revertTo[NAVI_STATE_KEY].revertTo;
            }
        }
        return __assign$6(__assign$6({}, state), (_b = {}, _b[NAVI_STATE_KEY] = {
            requestDataWithoutState: requestDataWithoutState,
            revertTo: revertTo,
        }, _b));
    }
    function unpackLocationState(state) {
        if (state === void 0) { state = {}; }
        var requestDataState = __assign$6({}, state);
        delete requestDataState[NAVI_STATE_KEY];
        var naviState = state[NAVI_STATE_KEY] || {};
        return __assign$6(__assign$6({}, naviState.requestDataWithoutState), { state: Object.keys(requestDataState).length ? requestDataState : undefined });
    }
    function revertLocationState(state) {
        if (state === void 0) { state = {}; }
        var naviState = state[NAVI_STATE_KEY] || {};
        return naviState.revertTo;
    }

    var __assign$7 = (undefined && undefined.__assign) || function () {
        __assign$7 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$7.apply(this, arguments);
    };
    function createBrowserNavigation(options) {
        // If there's a server state on the window object, use it and then remove
        // it so that it won't be picked up by any nested navigation objects.
        if (!options.state &&
            typeof window !== undefined &&
            window['__NAVI_STATE__']) {
            options.state = window['__NAVI_STATE__'];
            delete window['__NAVI_STATE__'];
        }
        var history$1 = options.history || history.createBrowserHistory();
        if (options.state) {
            history$1.replace(__assign$7(__assign$7({}, history$1.location), { state: options.state }));
        }
        var navigation = new Navigation({
            history: history$1,
            basename: options.basename,
            context: options.context,
            routes: options.routes,
            trailingSlash: options.trailingSlash,
        });
        navigation.refresh();
        return navigation;
    }

    var __assign$8 = (undefined && undefined.__assign) || function () {
        __assign$8 = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign$8.apply(this, arguments);
    };
    function createMemoryNavigation(options) {
        var url = options.url || (options.request && options.request.url);
        if (!url) {
            throw new Error("createMemoryNavigation() could not find a URL.");
        }
        var history$1 = history.createMemoryHistory({
            // The initial entry is ignored, and replaced during the call
            // to navigate below.
            initialEntries: ['/'],
        });
        var navigation = new Navigation({
            history: history$1,
            basename: options.basename,
            context: options.context,
            routes: options.routes,
            trailingSlash: options.trailingSlash,
        });
        navigation.navigate(__assign$8(__assign$8({}, options.request), { url: url, replace: true }));
        return navigation;
    }

    //

    exports.crawl = crawl;
    exports.resolve = resolve;
    exports.compose = compose;
    exports.Router = Router;
    exports.createRouter = createRouter;
    exports.routeReducer = routeReducer;
    exports.concatMatcherIterators = concatMatcherIterators;
    exports.Navigation = Navigation;
    exports.resolveChunks = resolveChunks;
    exports.createBrowserNavigation = createBrowserNavigation;
    exports.createMemoryNavigation = createMemoryNavigation;
    exports.lazy = map;
    exports.map = map;
    exports.mount = mount;
    exports.redirect = redirect;
    exports.route = route;
    exports.withContext = withContext;
    exports.withCrawlerPatterns = withCrawlerPatterns;
    exports.withData = withData;
    exports.withHead = withHead;
    exports.withHeaders = withHeaders;
    exports.withState = withState;
    exports.withStatus = withStatus;
    exports.withTitle = withTitle;
    exports.withView = withView;
    exports.NaviError = NaviError;
    exports.NotFoundError = NotFoundError;
    exports.OutOfRootError = OutOfRootError;
    exports.createChunk = createChunk;
    exports.createNotFoundChunk = createNotFoundChunk;
    exports.createURLDescriptor = createURLDescriptor;
    exports.parseQuery = parseQuery;
    exports.stringifyQuery = stringifyQuery;
    exports.joinPaths = joinPaths;
    exports.modifyTrailingSlash = modifyTrailingSlash;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
