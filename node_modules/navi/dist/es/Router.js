import { createRootMapping, matchAgainstPathname } from './Mapping';
import { ChunkListObservable } from './ChunkListObservable';
import { ChunksMapObservable } from './ChunksMapObservable';
import { routeReducer } from './Route';
import { createPromiseFromObservable } from './Observable';
import { createURLDescriptor } from './URLTools';
import { OutOfRootError } from './Errors';
export function createRouter(options) {
    return new Router(options);
}
var Router = /** @class */ (function () {
    function Router(options) {
        this.context = options.context || {};
        this.matcherGenerator = options.routes();
        var basename = options.basename;
        if (basename && basename.slice(-1) === '/') {
            basename = basename.slice(0, -1);
        }
        this.rootMapping = createRootMapping(options.routes, basename);
    }
    // Please don't document this API. It should only be used through
    // "createBrowserNavigation()" or "createMemoryNavigation()"
    Router.prototype.setContext = function (context) {
        this.context = context || {};
    };
    Router.prototype.createObservable = function (url, options) {
        var request = {
            body: options.body,
            context: this.context,
            headers: options.headers || {},
            method: options.method || 'GET',
            hostname: url.hostname,
            hash: url.hash,
            mountpath: '/',
            params: url.query,
            query: url.query,
            search: url.search,
            url: url.pathname + url.search,
            originalUrl: url.href,
            path: url.pathname,
            crawler: options.crawler,
            state: options.state || {},
        };
        var matchRequest = matchAgainstPathname(request, this.rootMapping);
        if (matchRequest) {
            return new ChunkListObservable(url, matchRequest, this.matcherGenerator);
        }
    };
    Router.prototype.createMapObservable = function (urlOrDescriptor, options) {
        if (options === void 0) { options = {}; }
        return new ChunksMapObservable(createURLDescriptor(urlOrDescriptor), this.context, this.matcherGenerator, this.rootMapping, this, options);
    };
    Router.prototype.resolve = function (urls, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var urlDescriptors;
        if (Array.isArray(urls)) {
            urlDescriptors = urls.map(function (url) { return createURLDescriptor(url); });
        }
        else if (typeof urls === 'string') {
            urlDescriptors = [createURLDescriptor(urls)];
        }
        else if (urls.url) {
            options = urls;
            urlDescriptors = [createURLDescriptor(options.url)];
        }
        else if (options) {
            urlDescriptors = [createURLDescriptor(urls)];
        }
        else {
            throw new Error("You must specify a URL for router.resolve().");
        }
        if (!urlDescriptors.length) {
            return Promise.resolve([]);
        }
        var promises = urlDescriptors.map(function (url) {
            return _this.getPageRoutePromise(url, options);
        });
        return !Array.isArray(urls) ? promises[0] : Promise.all(promises);
    };
    Router.prototype.resolveSiteMap = function (urlOrDescriptor, options) {
        if (options === void 0) { options = {}; }
        return createPromiseFromObservable(this.createMapObservable(urlOrDescriptor, options)).then(function (chunksMap) {
            var routeMap = {};
            var redirectMap = {};
            var urls = Object.keys(chunksMap);
            for (var i = 0; i < urls.length; i++) {
                var url = urls[i];
                var chunks = chunksMap[url];
                var lastChunk = chunks[chunks.length - 1];
                if (lastChunk.type === 'redirect') {
                    redirectMap[url] = lastChunk.to;
                    continue;
                }
                else {
                    routeMap[url] = [{ type: 'url', url: createURLDescriptor(url) }]
                        .concat(chunks)
                        .reduce(routeReducer, undefined);
                }
            }
            return {
                routes: routeMap,
                redirects: redirectMap,
            };
        });
    };
    Router.prototype.resolveRouteMap = function (urlOrDescriptor, options) {
        if (options === void 0) { options = {}; }
        return this.resolveSiteMap(urlOrDescriptor, options).then(function (siteMap) { return siteMap.routes; });
    };
    Router.prototype.getPageRoutePromise = function (url, options) {
        var _this = this;
        var observable = this.createObservable(url, options);
        if (!observable) {
            return Promise.reject(new OutOfRootError(url));
        }
        return createPromiseFromObservable(observable).then(function (chunks) {
            for (var i = 0; i < chunks.length; i++) {
                var chunk = chunks[i];
                if (chunk.type === 'busy') {
                    break;
                }
                if (chunk.type === 'redirect' && options.followRedirects) {
                    return _this.getPageRoutePromise(createURLDescriptor(chunk.to), options);
                }
                if (chunk.type === 'error') {
                    throw chunk.error;
                }
            }
            return [{ type: 'url', url: createURLDescriptor(url) }]
                .concat(chunks)
                .reduce(routeReducer, undefined);
        });
    };
    return Router;
}());
export { Router };
//# sourceMappingURL=Router.js.map