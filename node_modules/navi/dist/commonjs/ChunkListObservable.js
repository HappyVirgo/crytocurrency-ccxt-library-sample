"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Observable_1 = require("./Observable");
var ChunkListObservable = /** @class */ (function () {
    function ChunkListObservable(url, request, matcherGenerator) {
        var _this = this;
        this.handleUnsubscribe = function (observer) {
            var index = _this.observers.indexOf(observer);
            if (index !== -1) {
                _this.observers.splice(index, 1);
            }
        };
        this.handleChange = function (listenId) {
            if (listenId === _this.lastListenId) {
                _this.lastListenId++;
                _this.refresh();
                var isDone = _this.result.done || _this.result.value.every(function (chunk) { return chunk.type !== 'busy'; });
                for (var i = 0; i < _this.observers.length; i++) {
                    var observer = _this.observers[i];
                    observer.next(_this.result.value);
                    if (isDone && observer.complete) {
                        observer.complete();
                    }
                }
                if (isDone) {
                    delete _this.matcherIterator;
                }
            }
        };
        this.refresh = function () {
            var result = _this.matcherIterator.next();
            if (result.value) {
                _this.result = result;
            }
            if (!_this.result.done) {
                var listenId_1 = ++_this.lastListenId;
                var handleUpdate = function () { return _this.handleChange(listenId_1); };
                Promise.race(_this.result.value
                    .filter(isBusy)
                    .map(pickChunkPromise)).then(handleUpdate, handleUpdate);
            }
        };
        this.url = url;
        this.lastListenId = 0;
        this.observers = [];
        this.matcherIterator = matcherGenerator(request);
    }
    ChunkListObservable.prototype.subscribe = function (onNextOrObserver, onError, onComplete) {
        if (!this.matcherIterator) {
            throw new Error("Can't subscribe to an already-complete RoutingObservable.");
        }
        var observer = Observable_1.createOrPassthroughObserver(onNextOrObserver, onError, onComplete);
        this.observers.push(observer);
        var subscription = new Observable_1.SimpleSubscription(this.handleUnsubscribe, observer);
        if (this.observers.length === 1) {
            this.handleChange(this.lastListenId);
        }
        return subscription;
    };
    return ChunkListObservable;
}());
exports.ChunkListObservable = ChunkListObservable;
function isBusy(chunk) {
    return chunk.type === 'busy';
}
function pickChunkPromise(chunk) {
    return chunk.promise;
}
//# sourceMappingURL=ChunkListObservable.js.map