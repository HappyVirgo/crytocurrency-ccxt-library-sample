import { History } from 'history';
import { Route } from './Route';
import { URLDescriptor } from './URLTools';
import { Observer, Observable, SimpleSubscription } from './Observable';
import { Matcher } from './Matcher';
export interface NavigationOptions<Context extends object> {
    /**
     * The Matcher that declares your app's pages.
     */
    routes: Matcher<Context>;
    /**
     * If provided, this part of any URLs will be ignored. This is useful
     * for mounting a Navi app in a subdirectory on a domain.
     */
    basename?: string;
    /**
     * This will be made available within your matcher through
     * the second argument passed to any getter functions.
     */
    context?: Context;
    /**
     * You can manually supply a history object. This is useful for
     * integration with react-router.
     *
     * By default, a browser history object will be created.
     */
    history: History;
    /**
     * Configures whether a trailing slash will be added or removed. By default,
     * the trailing slash will be removed.
     */
    trailingSlash?: 'add' | 'remove' | null;
}
export interface NavigateOptionsWithoutURL {
    body?: any;
    headers?: {
        [name: string]: string;
    };
    method?: string;
    state?: any;
    /**
     * Whether to replace the current history entry.
     */
    replace?: boolean;
}
export interface NavigateOptions extends NavigateOptionsWithoutURL {
    url: string | Partial<URLDescriptor>;
}
export declare class Navigation<Context extends object = any> implements Observable<Route> {
    private _router;
    _history: History;
    private lastHandledLocation?;
    private navigationsSinceSteady;
    private basename?;
    private matcher;
    private waitUntilSteadyDeferred?;
    private observers;
    private lastRoute?;
    private ignoreNextLocationChange?;
    private isLastRouteSteady;
    private observableSubscription?;
    private unlisten;
    private trailingSlash;
    constructor(options: NavigationOptions<Context>);
    dispose(): void;
    go(n: number): Promise<Route<any>>;
    goBack(): Promise<Route<any>>;
    goForward(): Promise<Route<any>>;
    navigate(url: string | Partial<URLDescriptor>, options?: NavigateOptionsWithoutURL): Promise<Route>;
    navigate(url: NavigateOptions): Promise<Route>;
    prefetch(url: string | Partial<URLDescriptor>): Promise<void>;
    refresh(): Promise<Route>;
    setContext(context: Context): Promise<Route>;
    /**
     * Get the latest Route object, regardless of whether it is loading.
     *
     * This is named as `getCurrentValue()` so that Navigation objects can be
     * used with React's `createSubscription()`, and other tools that follow
     * the same specification.
     */
    getCurrentValue(): Route;
    /**
     * If loading, returns a promise to the non-busy route. Otherwise, returns
     * the current route.
     */
    getRoute(): Promise<Route>;
    /**
     * Returns the current history state
     */
    extractState(): any;
    /**
     * If you're using code splitting, you'll need to subscribe to changes to
     * Route, as the route may change as new code chunks are received.
     */
    subscribe(onNextOrObserver: Observer<Route> | ((value: Route) => void), onError?: (error: any) => void, onComplete?: () => void): SimpleSubscription;
    private handleUnsubscribe;
    private handleLocationChange;
    private handleChunkList;
    private setRoute;
}
